\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}

\lstset{
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!5},
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{purple}
}

\title{Practical Work 2: RPC File Transfer System using gRPC}
\author{Hoang Minh Quan\\ID: 23BI14371}
\date{}

\begin{document}
\maketitle

\section{Introduction}

This report presents the design and implementation of a Remote Procedure
Call (RPC)-based file transfer system using the gRPC framework in C++.
The objective is to provide a simple one-to-one file transfer service in
which a client can send a file to a server through remote procedure
calls instead of directly using low-level socket operations.

\section{System Goal}

The main goals of the system are:
\begin{itemize}
    \item to implement a single client and a single server,
    \item to transfer file data from the client to the server,
    \item to use RPC as the primary communication mechanism,
    \item to define a clear service interface via a \texttt{.proto} file.
\end{itemize}

The system uses gRPC over TCP/IP and Protocol Buffers for message
serialization.

\section{RPC Interface Specification}

The interface between the client and the server is defined in the file
\texttt{file\_transfer.proto}. This file specifies the RPC service
\texttt{FileTransfer} and the request/response message formats.

\subsection*{Protocol Definition}

\begin{lstlisting}[language=Proto,caption={RPC Service Definition: file_transfer.proto}]
syntax = "proto3";

package filetransfer;

service FileTransfer {
    rpc SendFile(FileRequest) returns (FileResponse) {}
    rpc ReceiveFile(FileChunk) returns (Empty) {}
}

message FileRequest {
    string filename = 1;
    bytes content = 2;
}

message FileResponse {
    bool success = 1;
}

message FileChunk {
    bytes content = 1;
}

message Empty {}
\end{lstlisting}

The \texttt{SendFile} RPC is used for sending a complete file from the
client to the server. The \texttt{ReceiveFile} RPC is defined to support
chunk-based transfer and future extensions.

\section{System Architecture}

The system architecture consists of:
\begin{itemize}
    \item a gRPC client that reads a file and calls \texttt{SendFile},
    \item a gRPC server that implements \texttt{SendFile} and
          \texttt{ReceiveFile},
    \item a \texttt{.proto} file shared by both sides,
    \item code generated by the Protocol Buffers compiler and gRPC
          plugins.
\end{itemize}

Conceptually, the architecture can be summarized as:

\begin{center}
\fbox{
Client Application
$\rightarrow$ gRPC Stub
$\rightarrow$ HTTP/2 over TCP
$\rightarrow$ gRPC Server
$\rightarrow$ File Storage
}
\end{center}

The client code invokes methods on the stub as if it were calling local
functions. gRPC transparently serializes the messages, sends them over
the network, and invokes the appropriate server-side implementation.

\section{Server Implementation}

The server implementation is contained in \texttt{server.cc}. It
registers an instance of \texttt{FileTransferServiceImpl} with a gRPC
server and waits for incoming RPC calls. :contentReference[oaicite:0]{index=0}

\begin{lstlisting}[language=C++,caption={Server implementation: server.cc}]
#include <iostream>
#include <memory>
#include <string>
#include <fstream>
#include <grpcpp/grpcpp.h>
#include "file_transfer.grpc.pb.h"

using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::Status;
using filetransfer::FileTransfer;
using filetransfer::FileRequest;
using filetransfer::FileResponse;
using filetransfer::FileChunk;
using filetransfer::Empty;

class FileTransferServiceImpl final : public FileTransfer::Service {

    Status SendFile(ServerContext* context, const FileRequest* request, FileResponse* response) override {

        std::ofstream file(request->filename(), std::ios::binary);
        if (!file.is_open()) {
            std::cerr << "Error opening file for writing" << std::endl;
            return Status::OK;
        }

        file.write(request->content().c_str(), request->content().length());
        file.close();

        response->set_success(true);
        return Status::OK;
    }

    Status ReceiveFile(ServerContext* context, const FileChunk* request, Empty* response) override {

        std::ofstream file("received_file.txt", std::ios::binary | std::ios::app);
        if (!file.is_open()) {
            std::cerr << "Error opening file for writing" << std::endl;
            return Status::OK;
        }

        file.write(request->content().c_str(), request->content().length());
        file.close();
        return Status::OK;
    }
};

void RunServer() {
    std::string server_address("0.0.0.0:50051");
    FileTransferServiceImpl service;

    ServerBuilder builder;
    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
    builder.RegisterService(&service);

    std::unique_ptr<Server> server(builder.BuildAndStart());
    std::cout << "Server listening on " << server_address << std::endl;
    server->Wait();
}

int main() {
    RunServer();
    return 0;
}
\end{lstlisting}

The method \texttt{SendFile} creates a file using the filename provided
in the \texttt{FileRequest} and writes the binary content into it. The
\texttt{ReceiveFile} method appends additional chunks to a file named
\texttt{received\_file.txt}, which allows the system to be extended with
chunk-based transfer.

\section{Client Implementation}

The client implementation is contained in \texttt{client.cc}. It
creates a stub to the \texttt{FileTransfer} service, reads a local file,
and sends it to the server using the \texttt{SendFile} RPC. :contentReference[oaicite:1]{index=1}

\begin{lstlisting}[language=C++,caption={Client implementation: client.cc}]
#include <iostream>
#include <fstream>
#include <string>
#include <grpcpp/grpcpp.h>
#include "file_transfer.grpc.pb.h"

using grpc::Channel;
using grpc::ClientContext;
using grpc::Status;
using filetransfer::FileTransfer;
using filetransfer::FileRequest;
using filetransfer::FileResponse;
using filetransfer::FileChunk;
using filetransfer::Empty;

class FileTransferClient {
public:
    FileTransferClient(std::shared_ptr<Channel> channel)
            : stub_(FileTransfer::NewStub(channel)) {}

    bool SendFile(const std::string& filename) {
        std::ifstream file(filename, std::ios::binary);
        if (!file.is_open()) {
            std::cerr << "Error opening file for reading" << std::endl;
            return false;
        }

        FileRequest request;
        request.set_filename(filename);
        std::string content((std::istreambuf_iterator<char>(file)), (std::istreambuf_iterator<char>()));
        request.set_content(content);

        FileResponse response;
        ClientContext context;
        Status status = stub_->SendFile(&context, request, &response);
        if (status.ok() && response.success()) {
            std::cout << "File sent successfully!" << std::endl;
            return true;
        } else {
            std::cerr << "Error sending file: " << status.error_message() << std::endl;
            return false;
        }
    }

    void ReceiveFile() {
        FileTransfer::Stub stub(grpc::CreateChannel("localhost:50051", grpc::InsecureChannelCredentials()));
        Empty request;
        FileChunk chunk;
        ClientContext context;

        std::ofstream file("received_file.txt", std::ios::binary);
        if (!file.is_open()) {
            std::cerr << "Error opening file for reading" << std::endl;
            return;
        }

        while (!file.eof()) {
            chunk.set_content(std::string((std::istreambuf_iterator<char>(file)), (std::istreambuf_iterator<char>())));
            Status status = stub.ReceiveFile(&context, chunk, &request);
            if (!status.ok()) {
                std::cerr << "Error receiving file: " << status.error_message() << std::endl;
                return;
            }
        }
        std::cout << "File received successfully!" << std::endl;
    }

private:
    std::unique_ptr<FileTransfer::Stub> stub_;
};

int main(int argc, char** argv) {
    FileTransferClient client(grpc::CreateChannel("localhost:50051", grpc::InsecureChannelCredentials()));
    client.SendFile("sample_file.txt");
    client.ReceiveFile();
    return 0;
}
\end{lstlisting}

The method \texttt{SendFile} reads the entire file into a
\texttt{std::string}, populates a \texttt{FileRequest} message, and
invokes the \texttt{SendFile} RPC. The \texttt{ReceiveFile} method
demonstrates how the client can call the \texttt{ReceiveFile} RPC on the
server to receive data, which can be extended into a full download
feature.

\section{Build and Execution}

To build and run the system, the following generic steps can be used:

\begin{enumerate}
    \item Generate gRPC and Protocol Buffers code from
          \texttt{file\_transfer.proto} using \texttt{protoc}.
    \item Compile \texttt{server.cc} and \texttt{client.cc} and link
          them with gRPC and Protocol Buffers libraries.
    \item Start the server executable.
    \item Run the client executable to send a sample file.
\end{enumerate}

Once the client has executed \texttt{SendFile}, the transferred file
appears in the server's working directory with the same file name.

\section{Conclusion}

This practical work demonstrates a complete RPC-based file transfer
system using gRPC in C++. The design is centered around a clear service
definition in \texttt{file\_transfer.proto}, and the client and server
implementations follow this interface to exchange file data reliably
over the network.

By using gRPC, the system avoids direct socket programming and relies on
high-level remote procedure calls, which simplifies development and
provides a structured way to extend the system with additional features
such as streaming, authentication, or integrity checks.

\end{document}
